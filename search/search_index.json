{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FRC Team 1246 Documentation","text":"<p>This website contains documentation for the FRC Team 1246, Agincourt Skunkworks. This documentation is designed for internal use, meaning some commands may reference our own repositories, and some information might be specific to us. However, a majority of this information can still be used in general, with at most a bit of modification, so we've left this public. You are free to fork, copy, and modify any of this information for your own use.</p> <p>This documentation site is not meant to replace the official FIRST &amp; WPILib documentation, but rather to supplement it with our own experiences and knowledge. While extremely common topics may be repeated here for ease of access, the official documentation should take precedence should any discrepancies arise (exceptions apply).</p> <p>Should any information not be covered here, you should refer to the official documentation, contact an experienced team member (via Discord), your mentor, or any other reliable source. Once you've done that, you should consider contributing it here for future reference!</p>"},{"location":"WIP/","title":"Work in Progress","text":"<p>Info</p> <p>This page is under construction, check back soon for updates. If this page would have contained information you needed, please ask in Discord.</p>"},{"location":"build/","title":"Build","text":"<p>This team is responsible for constructing the physical robot. For incoming members, this is often their first introduction to the team, as there are many entry-level tasks where they are able to develop general hand and power tool competencies. However, larger components often necessitate training on various machines in the shop, accessible to the students who are enrolled in manufacturing technology courses. Contrary to the term \"Build Season\", it is best to complete a functional version of the robot early on to enable the electrical, programming, and drive teams enough time to focus on their respective tasks.</p>"},{"location":"business/","title":"Business","text":"<p>This team is responsible for the financial sustainability of the team. Members of this team connect to, and keep record of, potential sponsors within the community through emails and phone calls. Through this process, sponsor relations are developed and maintained to ensure a consistent flow of funds. While monetary donations allow for higher control over fund allocation, resources(1) are equally appreciated. Many tasks involved are entry-level and build strong communication, negotiation, organization skills, and patience that are practical on the team and in real-world situations.</p> <ol> <li>ex. laptops, materials, and tools</li> </ol>"},{"location":"design/","title":"Design","text":"<p>This team focuses on the initial concept of the Robot. Through use of CAD(1), ideally, a working digital model of the Robot mechanisms will be the first priority (completed alongside build) to serve as a resource for build dimensions, the placement of electrical components, and as future reference for later seasons. Therefore, a coherent design must be decided within the 1-2 weeks of build season.</p> <ol> <li>ex. Fusion 360, Solidworks</li> </ol> <p>The documentation in this section is intended to help design team members in the design process to rapidly design a robot.</p>"},{"location":"electrical/","title":"Electrical","text":"<p>This team is responsible for designing, implementing, and maintaining the electrical systems of the robot. This includes the power distribution systems, communication systems, motors, sensors, and any other electrical components on the robot. The electrical team is also generally considered the team responsible for handling the pneumatic systems as well. The electrical team works closely with both the mechanical and software teams to ensure the seamless integration of electrical components with the robot's mechanical structure and software systems. General electrical knowledge, and skills such as soldering, and troubleshooting are of great benefit.</p>"},{"location":"programming/","title":"Programming","text":"<p>This team is responsible for designing and maintaining the software that runs on the robot. This can include the robot's control system, autonomous routines, computer vision, and more. The programming team is also generally responsible for updating and flashing any related firmware, such as on the RoboRIO, radio, and motor controllers. The programming team works closely with both the electrical and design teams to ensure the seamless integration of software with the robot's electrical components and mechanical structure. General programming knowledge, and skills in Java, systems design, control algorithms, version control, and troubleshooting are of great benefit.</p> <p>Additional responsibilities may also include GitHub &amp; Discord administration, documentation, scouting software, data analysis, and more.</p>"},{"location":"programming/control-algorithms/","title":"Control Algorithms","text":"<p>When it comes to interacting with the physical world, we often need to control moving components in a precise manner. This is done by using control algorithms that can be implemented in software to control the movement of motors, actuators, and other devices based on information obtained from various sensors. In FRC, the most common control algorithms are Bang Bang control, or PID control, which we cover in this section.</p>"},{"location":"programming/control-algorithms/bang-bang/","title":"Bang-Bang Control","text":""},{"location":"programming/control-algorithms/bang-bang/#use-cases","title":"Use Cases","text":"<p>Bang-Bang control is a simple but effective control algorithm when used in the right context. It is most suited for applications where the system's behaviour can be easily achieved by switching the system on or off based on certain conditions. Here are some scenarios where Bang-Bang control may be used in FRC:</p> <ul> <li>Spinning the intake motors while a game piece is detected</li> <li>Turning on the shooter motors when a game piece is detected in the shooter mechanism</li> </ul> <p>You'll notice that these use cases are all binary in nature, where the system's activation is based on whether a simple condition is met or not. Bang-Bang control will not be able to account for complex scenarios or where external factors may affect the system's behaviour. In those cases, more sophisticated control such as PID should be considered instead.</p>"},{"location":"programming/control-algorithms/bang-bang/#theory","title":"Theory","text":"<pre><code>graph LR\n  s([Start]) --&gt; c{Condition}\n  c ---&gt; |True| ta[State A]\n  c ---&gt; |False| tb[State B]\n  ta ---&gt; c\n  tb ---&gt; c</code></pre>"},{"location":"programming/control-algorithms/bang-bang/#principle","title":"Principle","text":"<p>Bang-Bang control is straightforward. You will continuously check if a condition is met or not. If the condition is met, you will switch the system to a certain state. If the condition is not met, you will switch the system to another state. Normally, this process will continue indefinitely, however, specific variants of Bang-Bang control may have additional conditions to stop the system, whether it be a sensor-based condition, a timeout, an interrupt, or something else.</p>"},{"location":"programming/control-algorithms/bang-bang/#signals","title":"Signals","text":""},{"location":"programming/control-algorithms/bang-bang/#input","title":"Input","text":"<p>The actual input to a Bang-Bang control algorithm should be a boolean value, however, it is common to use a sensor reading or a calculated value that can be converted to a boolean value based on a threshold. Examples of inputs can include a limit switch (triggered?), gyro reading (within threshold), a motor encoder reading (within threshold), etc.</p>"},{"location":"programming/control-algorithms/bang-bang/#output","title":"Output","text":"<p>There are two possible output states for a Bang-Bang control algorithm. The actual states themselves will vary based on what you are controlling with the algorithm. Examples of outputs can include motors (predefined speeds, perhaps 50% and 0%), solenoids (extended and retracted), etc.</p>"},{"location":"programming/control-algorithms/bang-bang/#tolerance","title":"Tolerance","text":"<p>It is rare for exact values to ever be achieved in real-world systems, and as such, it is important to account for this in your algorithms. For Bang-Bang control, if you were to switch the system on and off based on an exact value you're looking to achieve, it would result in the system constantly switching on and off as it overshoots and undershoots the target value. To prevent this, a tolerance value is usually used to give the system more time to settle before trying to correct it again. Depending on how fast the error changes, and how fine the corrections need to be, the tolerance value may need to be adjusted, a more sophisticated condition used, or a different control algorithm altogether.</p>"},{"location":"programming/control-algorithms/bang-bang/#sample-implementation","title":"Sample Implementation","text":""},{"location":"programming/control-algorithms/bang-bang/#scenario","title":"Scenario","text":"<p>We have an intake mechanism with a sensor that detects if a game piece is present. We want to intake the game piece when it is detected, and stop intaking when it is no longer detected. We will be assuming a simplified intake sequence that only requires that a motor be turned on or off, although in a real-world scenario, you may need to consider movement of the intake mechanism, solenoids to control the game piece's position in the mechanism, etc.</p>"},{"location":"programming/control-algorithms/bang-bang/#flowchart","title":"Flowchart","text":"<pre><code>graph LR\n  s([Start]) --&gt; c{Game Piece Detected?}\n  c ---&gt; |True| ta[Set Intake Motors to INTAKE_SPEED]\n  ta ---&gt; c\n  c ---&gt; |False| tb[\"Set Intake Motors to 0 (Stop)\"]\n  tb ---&gt; c</code></pre>"},{"location":"programming/control-algorithms/bang-bang/#code","title":"Code","text":"<p>The sample code assumes that the periodic function is placed in a command, as this will allow it to run periodically without interfering with the event loop (rest of the code). This also allows for the command to be interrupted when needed, without a stop condition in the code. It is assumed that the sensor is an digital input with an open (<code>true</code>) and closed (<code>false</code>) state, and the intake motor's <code>.set()</code> method is used to set the motor speed. <code>INTAKE_SPEED</code> is assumed to be a constant predefined speed for the motor to intake the game piece.</p> <pre><code>@Override\npublic void periodic() {\n    if (sensor.get()) intakeMotor.set(INTAKE_SPEED);\n    else intakeMotor.set(0);\n}\n</code></pre>"},{"location":"programming/control-algorithms/bang-bang/#helpful-links","title":"Helpful Links","text":"<ul> <li>Wikipedia</li> </ul>"},{"location":"programming/control-algorithms/pid/","title":"PID Control","text":"<p>While math is inevitable when talking about PID, this documentation is designed to use as little math as possible, and instead focus on the practical and basic theoretical aspects of PID control. You can find more detailed information on the math behind PID in the Helpful Links section.</p>"},{"location":"programming/control-algorithms/pid/#use-cases","title":"Use Cases","text":"<p>PID control, or Proportional-Integral-Derivative control, is a sophisticated &amp; flexible control algorithm that is commonly used in scenarios where precise and efficient control of various mechanisms is needed. PID is able to account for a wide range of scenarios, including those where external factors may affect the system's behaviour. It can run until a certain condition is met, or run infinitely to maintain a certain state. Here are some scenarios where PID control may be used in FRC:</p> <ul> <li>Controlling the position of an arm or elevator mechanism</li> <li>Driving on a balancing mechanism until a certain angle is achieved</li> <li>Following a predefined path using a motion profile</li> </ul> <p>You'll notice that these scenarios are more advanced than those where Bang-Bang control would be used.</p>"},{"location":"programming/control-algorithms/pid/#theory","title":"Theory","text":"<pre><code>flowchart LR\n    s([Start]) --&gt; ce[Calculate Error]\n    ce --&gt; p[Calculate P]\n    ce --&gt; i[Calculate I]\n    i --&gt; ic[Cap I]\n    ce --&gt; d[Calculate D]\n    p --&gt; |+| o[Calculate Output]\n    ic --&gt; |+| o\n    d --&gt; |+| o\n    o --&gt; so[Set Output]\n    so --&gt; s</code></pre>"},{"location":"programming/control-algorithms/pid/#principle","title":"Principle","text":"<p>For all equations, \\(e(t)\\) is the error at time \\(t\\), \\(K_p\\) is the proportional gain, \\(K_i\\) is the integral gain, \\(K_d\\) is the derivative gain, and \\(t\\) is the time. The result of the PID control algorithm is the sum of the three components: \\(\\text{output} = P(t) + I(t) + D(t)\\)</p>"},{"location":"programming/control-algorithms/pid/#p-proportional","title":"P (Proportional)","text":"\\[ P(t) = K_p\\cdot e(t) \\] <p>The proportional term is the most straightforward of the three components. It is simply the error multiplied by a constant gain. The proportional term is responsible for the immediate response of the system to changes in the error. A higher proportional gain will result in a faster response to changes in the error, but may also result in overshooting the target value.</p> <p>The proportional term is what provides most of the output in the PID controller. The integral and derivative terms are used to fine-tune the output, and allow the system to respond to changes more effectively, but the proportional term is what provides the bulk of the output.</p> <p>SIMPLIFIED: The proportional term directly scales the error to the output based on a constant. The relationship between the error and the P term output is linear. A higher constant will result in a more aggressive response to the error, but may also result in overshooting the target value.</p> Graph <p>{     \"title\": \"Sample Proportional Output vs Error Graph\",     \"data\": {         \"values\": [             {\"error\": 0, \"output\": 0},             {\"error\": 10, \"output\": 5},             {\"error\": 20, \"output\": 10}         ]     },     \"mark\": \"line\",     \"encoding\": {         \"x\": {\"field\": \"error\", \"type\": \"quantitative\", \"title\": \"Error\", \"axis\": {\"labels\": false}},         \"y\": {\"field\": \"output\", \"type\": \"quantitative\", \"title\": \"Proportional Output\", \"axis\": {\"labels\": false}}     } }</p>"},{"location":"programming/control-algorithms/pid/#i-integral","title":"I (Integral)","text":"\\[ I(t) = K_i\\cdot\\int_0^t e(\\tau) d\\tau \\] <p>The integral term is used to account for the accumulated error over time. It is the sum of the error over time, multiplied by a constant gain. The integral term is responsible for correcting any steady-state error that may be present in the system. A higher integral gain will result in a faster correction of steady-state error, but may also result in overshooting the target value.</p> <p>SIMPLIFIED: The integral term accumulates the error over time, which allows the system to overcome any resistances that may be present.</p> Graph <p>{     \"title\": \"Sample Position vs. Time Graph\",     \"data\": {         \"values\": [             {\"legend\": \"Setpoint\", \"time\": 0, \"position\": 4},             {\"legend\": \"Setpoint\", \"time\": 4, \"position\": 4},             {\"legend\": \"System wo/ Integral\", \"time\": 0, \"position\": 0},             {\"legend\": \"System wo/ Integral\", \"time\": 0.5, \"position\": 3.5},             {\"legend\": \"System wo/ Integral\", \"time\": 4, \"position\": 3.5},             {\"legend\": \"System w/ Integral\", \"time\": 0, \"position\": 0},             {\"legend\": \"System w/ Integral\", \"time\": 0.46, \"position\": 3.5},             {\"legend\": \"System w/ Integral\", \"time\": 0.9, \"position\": 4},             {\"legend\": \"System w/ Integral\", \"time\": 4, \"position\": 4}         ]     },     \"mark\": {         \"type\": \"line\",         \"interpolate\": \"monotone\"     },     \"encoding\": {         \"x\": {\"field\": \"time\", \"type\": \"temporal\", \"title\": \"Time\", \"axis\": {\"labels\": false}},         \"y\": {\"field\": \"position\", \"type\": \"quantitative\", \"title\": \"Position\", \"axis\": {\"labels\": false}},         \"color\": {\"field\": \"legend\", \"type\": \"nominal\", \"title\": \"Legend\"}     } }</p> <p>In this sample graph, we are assuming that there is resistance present in the system that is not accounted for in the P term, and in the system with the integral term, it is well-tuned. As can be seen, the system without the integral term is unable to reach the setpoint, and instead has a steady-state error. The system with the integral term, however, is able to accumulate the error over time, which allows it to overcome the resistance and reach the setpoint.</p> <p>Example</p> <p>Consider a PID controller with only a P term that is being used to drive a set distance. If we encounter a slight uphill slope that was not accounted for in the P term, the output may not be high enough to overcome the resistance. Now, if we were to add an I term, it would accumulate the error over time, which slowly increases the output, allowing the system to overcome the resistance.</p>"},{"location":"programming/control-algorithms/pid/#integral-windup","title":"Integral Windup","text":"<p>Integral windup is a phenomenon that causes the integral term to build up an unexpectedly large value. This can happen when the system does not respond quickly enough to correct a large error. This results in the output of the PID controller being excessively high, which can cause the system to go too fast, overshoot the target value, or similar.</p> <p>There are multiple methods that can be used to mitigate the problem of integral windup. However, the most common method we use in FRC is to cap the integral term at a specific value, which we do not want it to exceed. This will prevent the integral term from building up an excessively large value that we are not able to handle, however will limit its ability to correct for large resistances.</p> Graph <p>{     \"title\": \"Sample Position vs. Time Graph\",     \"data\": {         \"values\": [             {\"legend\": \"Setpoint\", \"time\": 0, \"position\": 4},             {\"legend\": \"Setpoint\", \"time\": 4, \"position\": 4},             {\"legend\": \"Setpoint\", \"time\": 4, \"position\": 2},             {\"legend\": \"Setpoint\", \"time\": 8, \"position\": 2},             {\"legend\": \"System w/ Integral (Capped)\", \"time\": 0, \"position\": 0},             {\"legend\": \"System w/ Integral (Capped)\", \"time\": 0.5, \"position\": 4},             {\"legend\": \"System w/ Integral (Capped)\", \"time\": 4, \"position\": 4},             {\"legend\": \"System w/ Integral (Capped)\", \"time\": 4.5, \"position\": 2},             {\"legend\": \"System w/ Integral (Capped)\", \"time\": 8, \"position\": 2},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 0, \"position\": 0},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 0.5, \"position\": 4.2},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 0.75, \"position\": 3.95},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 1, \"position\": 4},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 4, \"position\": 4},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 4.5, \"position\": 1.80},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 4.75, \"position\": 2.05},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 5, \"position\": 2},             {\"legend\": \"System w/ Integral (Uncapped)\", \"time\": 8, \"position\": 2}         ]     },     \"mark\": {         \"type\": \"line\",         \"interpolate\": \"monotone\"     },     \"encoding\": {         \"x\": {\"field\": \"time\", \"type\": \"temporal\", \"title\": \"Time\", \"axis\": {\"labels\": false}},         \"y\": {\"field\": \"position\", \"type\": \"quantitative\", \"title\": \"Position\", \"axis\": {\"labels\": false}},         \"color\": {\"field\": \"legend\", \"type\": \"nominal\", \"title\": \"Legend\"}     } }</p> <p>In this sample graph, we are assuming that there is little resistance present in the system that is not accounted for in the P term, and the integral gain is on the high side. As can be seen, the system with the uncapped integral term overshoots the setpoint. This is a result of integral windup, and can be [mostly] mitigated by capping the integral term (or using other measures), as shown in the capped variant, where there is little to no overshooting.</p>"},{"location":"programming/control-algorithms/pid/#d-derivative","title":"D (Derivative)","text":"\\[ D(t) = K_d\\cdot\\frac{de(t)}{dt} \\] <p>The derivative term is used to account for the rate of change of the error. It is the derivative of the error with respect to time, multiplied by a constant gain. The derivative term is responsible for smoothing out the response of the system to changes in the error. A higher derivative gain will result in a faster response to changes in the error, but may also result in oscillations around the target value.</p> <p>By smoothing out the response with the derivate term, we are also able to use a higher proportional gain (P term) which would allow the system to respond faster to the error. The derivative term will then slow down the system as it approaches the target value, which prevents the system from overshooting, even with this aggressive response. This is commonly used in applications where time to reach the target value is important, but we still want to avoid overshooting (and thus, time to correct), as much as possible.</p> <p>SIMPLIFIED: The derivative term calculates the rate of change of the error, which allows the system to adjust the output for a smoother response. Essentially, as the error approaches the target value, the derivative term will reduce the output to prevent overshooting.</p> Graph <p>{     \"title\": \"Sample Position vs. Time Graph\",     \"data\": {         \"values\": [             {\"legend\": \"Setpoint\", \"time\": 0, \"position\": 1},             {\"legend\": \"Setpoint\", \"time\": 6, \"position\": 1},             {\"legend\": \"Underdamped\", \"time\": 0, \"position\": 0},             {\"legend\": \"Underdamped\", \"time\": 0.4, \"position\": 1.6},             {\"legend\": \"Underdamped\", \"time\": 0.8, \"position\": 0.7},             {\"legend\": \"Underdamped\", \"time\": 1.2, \"position\": 1.15},             {\"legend\": \"Underdamped\", \"time\": 1.6, \"position\": 0.925},             {\"legend\": \"Underdamped\", \"time\": 2, \"position\": 1.0375},             {\"legend\": \"Underdamped\", \"time\": 2.4, \"position\": 0.98125},             {\"legend\": \"Underdamped\", \"time\": 2.8, \"position\": 1},             {\"legend\": \"Underdamped\", \"time\": 6, \"position\": 1},             {\"legend\": \"Critically Damped\", \"time\": 0, \"position\": 0},             {\"legend\": \"Critically Damped\", \"time\": 3, \"position\": 1},             {\"legend\": \"Critically Damped\", \"time\": 6, \"position\": 1},             {\"legend\": \"Overdamped\", \"time\": 0, \"position\": 0},             {\"legend\": \"Overdamped\", \"time\": 5.5, \"position\": 1},             {\"legend\": \"Overdamped\", \"time\": 6, \"position\": 1}         ]     },     \"mark\": {         \"type\": \"line\",         \"interpolate\": \"monotone\"     },     \"encoding\": {         \"x\": {\"field\": \"time\", \"type\": \"temporal\", \"title\": \"Time\", \"axis\": {\"labels\": false}},         \"y\": {\"field\": \"position\", \"type\": \"quantitative\", \"title\": \"Position\", \"axis\": {\"labels\": false}},         \"color\": {\"field\": \"legend\", \"type\": \"nominal\", \"title\": \"Legend\", \"legend\": {             \"values\": [\"Setpoint\", \"Underdamped\", \"Overdamped\", \"Critically Damped\"]         }}     } }</p> <p>In this sample graph, we are assuming that we have an aggressive proportional gain. The different lines represent different amounts of damping (from the derivative term) being applied, and how it affects the system's response.</p> <ul> <li>Underdamped: Can occur when an aggressive proportional gain is set, with an insufficiently large derivative gain (damp). Results in oscillations around the set point, until settled.</li> <li>Overdamped: Can occur when the derivative gain (damp) is too large for the proportional gain. Results in a longer than necessary time to reach the set point.</li> <li>Critically Damped: A well-tuned derivative term (damp) for the proportional term.</li> </ul> <p>Example</p> <p>Consider a PID controller with only a P term that is being used to drive a set distance. If we encounter a sudden downhill slope that was not accounted for in the P term, the output may be too high, causing the system to overshoot the target value. Now, if we were to add a D term, it would calculate the rate of change of the error, which would reduce the output as the error approaches the target value, slowing it down and preventing overshooting.</p>"},{"location":"programming/control-algorithms/pid/#signals","title":"Signals","text":""},{"location":"programming/control-algorithms/pid/#input","title":"Input","text":"<p>The input to a PID controller should be the error of the system. The error is the difference between the desired value and the actual value of the system. The error can be calculated using sensors, encoders, or other feedback mechanisms that provide information about the system's state. A common use case of PID, to reach a desired motor position, uses the difference between the desired position of the motor in encoder ticks (set point) and the current position of the motor in encoder ticks (feedback).</p>"},{"location":"programming/control-algorithms/pid/#output","title":"Output","text":"<p>The output of a PID controller is a variable value that is used to control the system. The device being controlled should be able to accept this variable value and adjust its state accordingly to achieve the intended effect. For example, motors, which are one of the most common use cases of PID, can accept the output of the PID controller as a percent speed value.</p>"},{"location":"programming/control-algorithms/pid/#tuning","title":"Tuning","text":"<p>The output of PID control needs to be adjusted to achieve the expected system response. This is done by tuning the three constants involved in PID, \\(K_p\\), \\(K_i\\), and \\(K_d\\). It is unlikely that estimated values for these constants will work well, and as such, a tuning process with the actual system is required to find the optimal values. This section of the documentation will cover the process of tuning a PID controller.</p>"},{"location":"programming/control-algorithms/pid/#setpoints","title":"Setpoints","text":"<p>The process of obtaining setpoints will differ depending on the input used for the PID controller. Generally, if it cannot be theoretically determined, it will consist of logging the input value continuously, physically manipulating the robot to the desired position, and recording the value. This should be done numerous times, with an average measurement taken to ensure an accurate reading.</p> <p>In FRC, using PID to reach (and/or hold) a particular motor position is common. While the setpoint for this could be theoretically determined with knowledge of the distance corresponding to each encoder tick (taking into account gearboxes and other physical attributes), this is often inaccurate as a result of real world conditions. Instead, it is highly suggested to experimentally determine the setpoint by following the above process: logging the encoder value, manually moving to that position, and recording the encoder value to use as the setpoint.</p> <p>Tip</p> <p>If you see during tuning that the system is constantly moving to the wrong position, it may be worth checking that the setpoint is accurate. If it is accurate, ensure that the encoder is properly zeroed in the expected position, and that shifts are not occurring in the gearbox or other mechanisms that could affect the encoder reading.</p>"},{"location":"programming/control-algorithms/pid/#initial-estimates","title":"Initial Estimates","text":""},{"location":"programming/control-algorithms/pid/#p-proportional_1","title":"P (Proportional)","text":"<p>A good starting point for the proportional gain is to take the maximum expected error, and ensure that will correspond to the maximum expected output of the system. This can be later adjusted to be higher or lower, depending on how the system responds.</p> <p>Or, mathematically, where \\(K_{p}\\) is the initial proportional gain, \\(e_{max}\\) is the maximum expected error, and \\(o_{max}\\) is the maximum expected output of the system:</p> \\[ K_{p} = \\frac{o_{max}}{e_{max}} \\] <p>Example</p> <p>If we are using a PID controller to control the position of a motor, taking difference in position as the input, and motor percent speed as the output, the maximum expected error would usually be the distance between the setpoint, and the furthest possible position. The expected output would usually be <code>1.0</code> (100%).</p> <p>If the maximum expected difference were 100 encoder ticks, then to calculate the initial \\(K_p\\) value, we would use the following calculation: \\(K_{p} = \\frac{1.0}{100} = 0.01\\), resulting in an initial value of <code>0.01</code>.</p> <p>If the application of the PID controller does not allow for a good estimate of the initial proportional gain, it is suggested to start with a low value, and increase it gradually until the system responds as expected. This prevents potentially hazardous situations that could arise from an extremely aggressive response.</p>"},{"location":"programming/control-algorithms/pid/#i-integral-and-d-derivative","title":"I (Integral) and D (Derivative)","text":"<p>Usually, the integral and derivative gains are set to zero initially, and are only adjusted as needed during the tuning process. This is because the integral and derivative terms are used to fine-tune the output of the system, or account for specific scenarios, and may not necessarily be needed in all cases. It should be obvious during the tuning process if the integral or derivative terms are needed, at which point they can be adjusted accordingly.</p>"},{"location":"programming/control-algorithms/pid/#tuning-process","title":"Tuning Process","text":"<p>Put simply, the process of tuning PID consists of testing the system, adjusting the constants based on the system's behaviour, and repeating until the system responds as expected. Knowing what constants to adjust, and by how much is a skill that comes with experience, and is not something that can be easily taught. However, the following guidelines can be used to help you get started:</p> <ol> <li>Start with the Proportional Gain: The proportional gain is the most important of the three constants, and should be adjusted first. Start with the initial estimate, and adjust it until the system responds as expected.<ul> <li>If the system moves slowly, or stalls often before reaching the setpoint, try increasing the proportional gain.</li> <li>If the system overshoots the setpoint by a large amount, or oscillates around the setpoint, try decreasing the proportional gain.</li> <li>If you find yourself unable to find a good balance between the two, try utilizing the integral and/or derivative terms, before adjusting the proportional gain further.</li> </ul> </li> <li>Evaluate the Integral Term: If the system is expected to encounter resistance that the proportional term cannot overcome, or if it is observed that there is a steady-state error that cannot be handled with the proportional term, the integral term should be implemented. Start with a low value, and increase it until the system responds as expected.<ul> <li>If the system does not appear to be compensating enough for resistance, try increasing the integral gain.</li> <li>If the system overshoots the setpoint, or oscillates around the setpoint, try decreasing the integral gain.</li> <li>If you find yourself in a position where the integral gain cannot be lowered further without being ineffective, but overshooting is still occurring in better conditions, try capping the integral term, or utilizing the derivative term to smooth out the response.</li> </ul> </li> <li>Evaluate the Derivative Term: If the system is tuned aggressively, and it is observed that the system often overshoots the setpoint, or the speed of the system nearing the setpoint is too high, the derivative term should be implemented. Start with a low value, and increase it until the system responds as expected.<ul> <li>If the system is still moving too fast, overshoots the setpoint, or oscillates around the setpoint, try increasing the derivative gain.</li> <li>If the system moves slowly, or stalls often before reaching the setpoint, try decreasing the derivative gain.</li> </ul> </li> <li>Repeat: After adjusting the constants, test the system again, and repeat the process by adjusting &amp; fine-tuning the constants until the system works well consistently under all conditions.</li> </ol>"},{"location":"programming/control-algorithms/pid/#sample-implementation","title":"Sample Implementation","text":""},{"location":"programming/control-algorithms/pid/#scenario","title":"Scenario","text":"<p>We have an arm mechanism with a motor attached at a pivot point. We want the arm to be able to move to a specific angle (motor position), and hold that position against gravity or other resistances.</p>"},{"location":"programming/control-algorithms/pid/#flowchart","title":"Flowchart","text":"<p>As PID control mostly varies not in implementation, but in the constants used, the flowchart provided in the Theory section would still be representative of this sample scenario.</p>"},{"location":"programming/control-algorithms/pid/#code","title":"Code","text":"<p>We will not be using the premade PID classes provided by WPILib, nor our own generic PID classes. Instead, we will be showing the relevant segments of a simple from-scratch PID controller that would be suitable for this use case. This should give you a better understanding of how PID works, and how it can be implemented or modified to suit your needs.</p> <p>We will be referencing a few other classes that are not shown here, such as the <code>Timer</code> class, provided by WPILib, to get the time, the <code>Controller</code> class, which represents a standard motor controller, and <code>PIDConstants</code>, which represents some class containing the necessary constants for the PID controller. The following class diagram shows the classes we will be using:</p> <pre><code>classDiagram\n    class Timer {\n        +getFPGATimestamp() double\n    }\n\n    class MotorController {\n        +getPosition() double\n        +setSpeed(double percentOutput)\n    }\n\n    class PIDConstants {\n        +double kP\n        +double kI\n        +double kIMax\n        +double kD\n    }</code></pre> <p>Please note that the following code segment is not complete, is more verbose than necessary, and only shows the parts relevant for PID logic. An actual implementation would necessitate additional code for Command-Based interaction, logging, QoL features (such as on-the-fly adjustment), and more.</p> <pre><code>private final Timer timer;\nprivate final MotorController motor;\nprivate final PIDConstants constants;\n\nprivate double errorSum = 0; // (1)!\nprivate double lastRunTime = 0; // (2)!\nprivate double lastError = 0; // (3)!\n\n// ...\n\n@Override\npublic void execute() {\n    if (lastRunTime == 0) lastRunTime = Timer.getFPGATimestamp(); // (4)!\n\n    // Calculate time since the last execution\n    final double currentTime = Timer.getFPGATimestamp();\n    final double dt = currentTime - lastRunTime;\n\n    // Calculate the error and error rate\n    final double error = setpoint - motor.getPosition(); // (5)!\n    final double errorRate = (error - lastError) / dt; // (6)!\n\n    // Accumulate the error\n    errorSum += error * dt; // (7)!\n    errorSum = Math.max(-constants.kIMax, Math.min(constants.kIMax, errorSum)); // (8)!\n\n    // Record values for next execution\n    lastRunTime = currentTime;\n    lastError = error;\n\n    // Calculate the PID output\n    final double p = constants.kP * error;\n    final double i = constants.kI * errorSum;\n    final double d = constants.kD * errorRate;\n    final double output = p + i + d;\n\n    // Set the motor speed\n    motor.setSpeed(output);\n}\n</code></pre> <ol> <li>Used to accumulate the error over time, for the integral term.</li> <li>Used to calculate the time since the last execution, for the derivative term.</li> <li>Used to calculate the rate of change of the error, for the derivative term.</li> <li>Prevents a large delta time value on the first execution, which would result in a large derivative term output.</li> <li>The error (difference between the setpoint and the current position) is used to calculate the proportional term. Remember that the proportional term is the error multiplied by a constant gain.</li> <li>The rate of change of the error is used to calculate the derivative term. Remember that the derivative term is the rate of change of the error, multiplied by a constant gain.</li> <li>Accumulates (sums) the error throughout the execution. We multiply the current error by the time, and add it to a running total, which is used to calculate the integral term. Remember that the integral term is the sum of the error over time, multiplied by a constant gain.</li> <li>We cap the integral term in a bound of <code>-kIMax</code> to <code>kIMax</code>. This is to prevent integral windup, where the integral term builds up an unexpectedly large value. You can read more about this in Integral Windup.</li> </ol>"},{"location":"programming/control-algorithms/pid/#helpful-links","title":"Helpful Links","text":"<ul> <li>Wikipedia<ul> <li>PID Controller</li> <li>Proportional Control</li> <li>Integral (Math)</li> <li>Derivative (Math)</li> </ul> </li> <li>FRC Documentation</li> <li>Video Guide (by FRC Team 6814):<ul> <li>Part 1</li> <li>Part 2</li> </ul> </li> <li>WPILib PID Implementation</li> <li>Sample Custom Generic PID Command</li> </ul>"},{"location":"programming/firmware/gyro-navx2/","title":"Gyro (NavX2) Calibration &amp; Firmware","text":"<p>This documentation is written for the KauaiLabs NavX2-MXP Gyro. If we end up using a different Gyro in the future, create a separate guide for it.</p>"},{"location":"programming/firmware/gyro-navx2/#mounting","title":"Mounting","text":"<p>Preferably, the Gyroscope should be mounted to the MXP port on the RoboRIO (this is the long port in the center of the RoboRIO, there is a connector on the back of the Gyroscope that fits this). However, in situations where the Gyroscope needs to be mounted elsewhere (which should be rare), mounting via SPI is then preferred (port on the top right of the RoboRIO, line of pins labeled <code>SPI</code> on the Gyroscope). If mounting via SPI is not possible, the last resort should be USB mounting (USB port on the RoboRIO, to the Mini USB port on the Gyroscope).</p>"},{"location":"programming/firmware/gyro-navx2/#calibration","title":"Calibration","text":"<p>The board almost always needs to be calibrated manually, otherwise the readings will be extremely inaccurate. This should be done anytime the Gyro is remounted, just in case. The calibration is done to ensure that the Gyroscope properly determines what mounting orientation it is in, so that the readings are proper and accurate. Theoretically if the mounting position is the same when moving the Gyroscope, a calibration isn't needed, but it's safer to do one anyhow.</p> <p>Full Calibration Guide</p> <p>Ensure that the robot is not moved during the calibration sequence</p> <ol> <li>Install the Gyroscope to the desired location. Ensure that one axis perpendicular to the ground (cannot be diagonal or slanted).</li> <li>Power on the robot and wait until the Gyroscope is on</li> <li>Press and hold the <code>CAL</code> button on the Gyroscope for 5 seconds.</li> <li>Release the <code>CAL</code> button. The orange light should flash (or in our case turn on, either is fine) for 1 second before turning off.</li> <li>Once the light has turned off, press the <code>RESET</code> button.</li> <li>The board is automatically calibrating, do not touch the robot or the board during this process. The orange LED should be slowly flashing during this process. It may take anywhere between 2-20 seconds.<ul> <li>If the orange LED begins flashing quickly at any point, there is an error in calibration. Either the Gyroscope is not mounted with one axis perpendicular to the ground, or the Gyroscope was moved during calibration. Power cycle (may or may not be optional), then reperform these steps to try again.</li> </ul> </li> <li>Calibration should be complete, values should be proper and calibration is no longer necessary until moved.</li> </ol>"},{"location":"programming/firmware/gyro-navx2/#code","title":"Code","text":""},{"location":"programming/firmware/gyro-navx2/#libraries","title":"Libraries","text":"<p>The Gyroscope needs a library to function, full installation instructions are available here, this is a short overview of the Online Installation Method.</p> <ol> <li>Open the project in VSCode</li> <li>Open Command Palette (Ctrl+P)</li> <li>Type in <code>&gt;WPILib: Manage Vendor Libraries</code>, and open that option</li> <li>Select the <code>Install new library (online)</code> option</li> <li>Enter the following link: <code>https://dev.studica.com/releases/20XX/NavX.json</code><ul> <li>Ensure that you replace the year placeholder, <code>20XX</code>, with the current year</li> <li>While the links from Studica usually follow this format, it may change. If the link is not working, search the official pages for the NavX gyroscope to locate the correct link</li> <li>If it is early in the year, the updated version may not have been released yet. You will need to remember to update this library when you migrate to the new season's WPILib version</li> </ul> </li> <li>Once the installation finishes, your library should be installed</li> </ol>"},{"location":"programming/firmware/gyro-navx2/#setup","title":"Setup","text":"<p>Depending on the method of connection (MXP, SPI, USB), the initialization code may need to be adjusted. This section is presuming that you are using MXP, you will need to do additional research for other methods of connection.</p> <p>The following imports are needed (one for the Gyro library, other for the port): <pre><code>import com.kauailabs.navx.frc.AHRS;\nimport edu.wpi.first.wpilibj.SPI;\n</code></pre></p> <p>Initialize the AHRS object (object used to obtain readings) by using the following line of code: <pre><code>AHRS ahrs = new AHRS(SPI.Port.kMXP);\n</code></pre></p> <p>This object can then be used to obtain readings, using the methods shown below.</p>"},{"location":"programming/firmware/gyro-navx2/#method-reference","title":"Method Reference","text":"<p>All of these need to be prefixed with the AHRS object. If the variable it is stored in is named <code>ahrs</code>, then it would be <code>ahrs.isConnected()</code> to call <code>isConnected()</code>, for example.</p> <p>This list does not include every possible reference. This list includes a few more, but not all. If you need all of them, use F12 (View Definition) while your cursor is on the AHRS object initialization, which will open the Source file for it. You can look through all the methods there.</p> <ul> <li><code>isConnected()</code>: Boolean value of whether the Gyroscope is connected (and subsequently whether readings can be obtained)</li> <li><code>zeroYaw()</code>: Set the current angle the robot is facing as the zero-point for YAW. (when you face this angle, <code>getYaw()</code> will read 0)</li> <li><code>getYaw()</code> or <code>getAngle()</code>: Reading for YAW (rotation around the Z axis, which is perpendicular to the earth) in degrees, from -180 to 180. If past 180, it will circle back to -180, and vice-versa. Turning left should normally be decreasing.</li> <li><code>getPitch()</code>: Reading for pitch (rotation around the X axis [up/down]) in degrees, from -180 to 180. If past 180, it will circle back to -180, and vice-versa. Down decreases, up increases.</li> <li><code>getCompassHeading()</code>: Supposedly the reading for compass heading, from 0 to 360, read using a mangnetometer. This reading did not work in our testing, it may be interference, lack of calibration, wrong usage, or it just doesn't work.</li> </ul>"},{"location":"programming/firmware/gyro-navx2/#helpful-links","title":"Helpful Links","text":"<ul> <li>Official Documentation</li> <li>Sample Gyro Subsystem</li> </ul>"},{"location":"programming/firmware/radio/","title":"Radio Firmware","text":"<p>Warning</p> <p>The documentation on this page is currently incomplete. You may still find useful information here, but it may be missing important details. If you have any questions, please ask in Discord.</p>"},{"location":"programming/firmware/radio/#downloading-radio-configuration-utility","title":"Downloading Radio Configuration Utility","text":"<p>Note</p> <p>If you have downloaded the FRC Game Tools package from NI, this tool should already have been installed. You should not need to download it again unless it's missing.</p> <p>The FRC Radio Configuration tool is needed to configure the radio. Please see the documentation for the up-to-date download link. After the tool is downloaded, unzip it, and use the EXE file to run the tool. Ensure that the tool is run as an Administrator (it should prompt you to do so if you don't) -- it will not work otherwise.</p>"},{"location":"programming/firmware/radio/#configuring-the-radio","title":"Configuring the Radio","text":"<p>Info</p> <p>This section is not yet completed</p>"},{"location":"programming/firmware/radio/#troubleshooting","title":"Troubleshooting","text":""},{"location":"programming/firmware/radio/#radio-is-not-turning-on","title":"Radio is not turning on","text":"<p>Ensure that the POE (Power over Ethernet, a.k.a. the orange Ethernet cable) is connected to the bottom (the one next to the barrel power connector), and that the barrel power connector is connected to the VRM (Voltage Regulator Module). For additional details, please see the electrical documentation. </p>"},{"location":"programming/firmware/radio/#what-network-interface-do-i-use","title":"What network interface do I use?","text":"<p>If prompted for a network interface (if you choose the wrong one earlier, you can use the Tools \u2192 Network Interface menu to change it), ensure that you have Ethernet selected. If Ethernet is not available in the list, ensure that the radio is on, an Ethernet cable is plugged in, and the Ethernet adapter is working.</p> <p>Do not select Local Area Connection, or anything other than Ethernet. They may seem to work, but they are incorrect</p>"},{"location":"programming/firmware/radio/#load-firmware-npf-drivername-error","title":"Load Firmware NPF Driver/Name Error","text":"<p>This happens when the configuration tool gets confused about which interface to use. The documentation provides this excerpt on it, however I'll go into more detail later:</p> <p>If you see an error about NPF name, try disabling all adapters other than the one being used to program the radio. If only one adapter is found, the tool should attempt to use that one. See the steps in Disabling Network Adapters for more info.</p> <p>As the documentation says, we'll need to disable all network adapters other than the one we're using. To do this, follow these steps:</p> <ol> <li>Press Windows + R to open the Run dialog</li> <li>Type in <code>control</code>, and press enter</li> <li>Select Network and Internet</li> <li>Select Network and Sharing Center</li> <li>Click <code>Change adapter settings</code> on the left panel</li> <li>For each adapter that is not \"Ethernet\" (or the one you're using, it may be under a different name):<ol> <li>Right-click the adapter</li> <li>Select <code>Disable</code></li> </ol> </li> <li>Ensure that every single adapter other than the one you're using is disabled. It doesn't matter if it seems like it shouldn't affect anything, it will.</li> <li>Close and reopen the Radio Configuration Tool</li> <li>Try to Load Firmware again</li> </ol>"},{"location":"programming/firmware/radio/#verification-issues","title":"Verification Issues","text":"<p>If you needed to disable your network adapters previously, you may need to re-enable them for verification to work. If during the verification process, an error occurs, try to re-enable your network adapters and try again. If this doesn't work, restart the program and try again -- it may take a couple of tries.</p>"},{"location":"programming/firmware/radio/#helpful-links","title":"Helpful Links","text":"<ul> <li>Official Documentation</li> </ul>"},{"location":"programming/generic-wrappers/","title":"Generic Wrappers","text":"<p>In FRC, we often need to interact with different electrical components to make the robot work, such as motor controllers and joysticks (or other input devices). We may also switch between different variants of these components relatively often. To both make the process of switching easier &amp; faster (which is important in competition), and reduce the amount of different libraries we need to remember how to use, we can create generic wrappers for these components.</p> <p>The idea is to create a class with generic functions that cover the functionality we need access to, and map these functions to the different library-specific functions that we need to call to make that component work. Then, we would specify which type of component we are using in a configuration file, and the wrapper would automatically use the correct implementations for that component. If needed, additional specifics like library enums can also be generalized and mapped to the correct values.</p> <p>This does come with the difficulty of ensuring that there is feature parity between the different libraries, so if one library we have support for has a feature but another doesn't, we may not be able to use that feature in our generic. However, by doing this, we ensure the code remains consistent and flexible, which is vital in fast-paced, high-stress environments like competitions.</p>"},{"location":"programming/generic-wrappers/joystick/","title":"Generic Joystick","text":"<p>Info</p> <p>This page is under construction, check back soon for updates. If this page would have contained information you needed, please ask in Discord.</p>"},{"location":"programming/generic-wrappers/motor-controller/","title":"Generic Motor Controller","text":"<p>Info</p> <p>This page is under construction, check back soon for updates. If this page would have contained information you needed, please ask in Discord.</p>"}]}